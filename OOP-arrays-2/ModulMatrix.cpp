/// \file ModulMatrix.cpp
/// \brief cpp-файл модуля ModulMatrix.cpp
/// \brief Созданы пространства имён
/// \brief Добавлена обработка исключительных ситуаций
/// \brief реализованы функции работы с массивом, 
/// \brief использованы vector вместо классических массивов
/// \author Бурдинская Наталья ВМК-22
/// \date 20.10.2023

#include "ModulMatrix.h"
// ПРОСТРАНСТВО ИМЕН ДЛЯ МАТРИЦЫ
namespace NamespaceMatrix
{
	// процедура заполнение матрицы, размером N x M, случайными числами
	vector_int CreateRandomMatrix(vector_int matr, int n, int m)
	{
		// n, m, matr – формальныe параметры
		// заполнение массива случайными числами от 0 до 100 включительно
		// нумерация (с 0 до n-1) х (с 0 до m-1)
		// Сочетание srand (time (NULL)) устанавливает в качестве базы текущее время.
		// Этот прием часто используется для того, чтобы при разных запусках генератора псевдослучайных чисел
		// была всякий раз разная база и, соответственно, разный ряд получаемых значений.
		// Генерирует случайное число, используя текущею дату, как параметр, как бы для непредсказуемости результата.
		srand(time(0)); // инициализация генератора случайных чисел текущим временем в секундах time
		for (unsigned i = 0; i < n; i++) // строк N
			for (unsigned j = 0; j < m; j++) // столбцов M
			{
				matr[i][j] = rand() % 100;
				// rand() возвращает случайное целое число от 0 до RAND_MAX
			}
		return matr;
	}

	// процедура вывода на консоль двумерного массива N х М
	// процедура ничего не возвращает
	void Print_Vector(const vector_int& matr, int n, int m)
	{
		// n, m, matr – формальныe параметры
		// матрица передаётся по ссылке & чтобы избежать лишнего копирования
		// т.к. эта функция не должна менять матрицу, то делаем формальный параметр константой
		// фактический параметр не обязательно должен быть константой
		for (int i = 0; i < n; ++i)
		{
			cout << "|"; // черточки для красоты отделения с двух сторон строки
			for (int j = 0; j < m; j++)
				cout << setw(5) << matr[i][j]; // m элементов в строке
			cout << "|" << endl;
		}
		cout << endl;
	}

	// функция создание новой матрицы N х M, с помощью перестановок столбцов
	// на входе будет матрица vector_int &matr
	// на выходе будет матрица vector_int &matr, созданная перестановкой столбцов
	vector_int Perestanovka(vector_int& matr, int n, int m)
	{

		// n, m, matr – формальныe параметры
		// инициализация двумерного массива нулями
		vector_int matrix; // временная динамическая матрица (пока пуста) 4х5
		// выделение памяти под строки матрицы 
		matrix.resize(n); // строки
		for (int i = 0; i < n; ++i)
			matrix[i].resize(m);
		int k = m / 2; // выделяем целую часть от деления
		int l = m % 2; // выделяем остаток от деления
		for (int i = 0; i < n; ++i)
		{
			for (int j = 0; j < k; j++)
			{
				matrix[i][j] = matr[i][m - j - 1];
				matrix[i][m - j - 1] = matr[i][j];
				// если количество столбцов нечетное, тот который в середине остается на мест		
				if (l == 1) matrix[i][k] = matr[i][k];
			}
		}
		matr = matrix;
		matrix.clear(); // освобождение памяти 
		return matr;
	}
}

// ПРОСТРАНСТВО ИМЕН ДЛЯ МАТРИЦЫ В ФАЙЛЕ
namespace NamespaceFile
{
	//процедура записи матрицы matr, размером N x M, в файл fmatrix.txt
	void WriteFile(vector_int matr, int n, int m)
	{
		// n, m, matr – формальныe параметры
		// Режим открытия файла для записи ios::out
		// устанавливается при создании файла
		ofstream Fin("fmatrix.txt", ios::out); // затирает старые и пишет новые данные
		Fin << n << endl;
		Fin << m << endl;
		// пишем в файл отправленные ссылкой константы Р
		for (int i = 0; i < n; ++i)
		{
			for (int j = 0; j < m; j++)
				Fin << setw(5) << matr[i][j]; // m элементов в строке
			Fin << endl;
		}
		Fin << endl;
		Fin.close(); /// Функция close() закрывает поток файла
		cout << "Write. End of recording" << endl;
	}

	//процедура добавления записи матрицы matr, размером N x M, в файл fmatrix.txt
	void AddFile(vector_int matr, int n, int m)
	{
		// n, m, matr – формальныe параметры
		// Режим открытия файла для записи ios::out
		// устанавливается при создании файла
		ofstream Fin("fmatrix.txt", ios::app); // затирает старые и пишет новые данные
		Fin << n << endl;
		Fin << m << endl;
		// пишем в файл отправленные ссылкой константы Р
		for (int i = 0; i < n; ++i)
		{
			for (int j = 0; j < m; j++)
				Fin << setw(5) << matr[i][j]; // m элементов в строке
			Fin << endl;
		}
		Fin << endl;
		Fin.close(); /// Функция close() закрывает поток файла
		cout << "Write. End of recording" << endl;
	}

	// процедура чтения матрицы matr, размером N x M, из файла fmatrix.txt
	vector_int ReadFile(vector_int matr, int n, int m)
	{
		// n, m, matr – формальныe параметры
		ifstream Fout; /// объявляем имя Fout для чтения
		//string s; /// переменная для красивого вывода данных из файла
		/// Режим открыть файл для чтения ios::in можно установить при
		///  вызове метода open(), необязательно при создании файла(процедура выше)
		Fout.open("fmatrix.txt", ios::in); /// открываем файл для чтения на начале
		/// пока есть записи в файле читаем их
		if (!Fout.eof())
		{
			Fout >> n;
			Fout >> m;
			for (int i = 0; i < n; ++i)
			{
				for (int j = 0; j < m; j++)
					Fout >> matr[i][j]; // m элементов в строке
			}
		}
		Fout.close(); /// Функция close() закрывает поток файла
		return matr;
	}
}
