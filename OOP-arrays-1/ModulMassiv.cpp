/// \file ModulMassiv.cpp
/// \brief cpp-файл модуль ModulMassiv.cpp
/// \author Бурдинская Наталья ВМК-22
/// \date 29.10.2023

// вызов заголовочного файла модуля ModulMassiv.cpp
#include "ModulMassiv.h"

// ПРОСТРАНСТВО ИМЕН ДЛЯ МАССИВА
namespace NamespaceMassiv
{
	//---функция выделение памяти для массива размерности n
	int* Memo_Mass(unsigned n)
	{
		// возвращает массив типа int, * одномерный
		// n – формальный параметр
		// динамический массив размерность n, инициализация всего массива нулями
		int* a = new int [n] {0};
		return a; // возврат массива А из функции Memo_Mass
	}

	//---процедура ввода массива размерности n
	// Динамические массивы в функции передаются как указатели *.
	// При этом нужно передавать размер через отдельный параметр (n).
	// ничего не возвращает, просто вводит данные в массив
	void Vvod_Mass(int* a, unsigned n)
	{
		// массив *a, n – формальные параметры
		// a передаётся как указатель на начало массива, n по значению
		// Генерирует случайное число, используя текущею дату, для непредсказуемости результата
		srand(time(0)); // инициализация генератора случайных чисел текущим временем в секундах time
		// заполнение массива случайными числами от -100 до 100 включительно
		for (unsigned i = 0; i < n; ++i) // нумерация с нуля до n-1
		{
			a[i] = rand() % 200 - 100;
			// rand() возвращает случайное целое число от 0 до RAND_MAX
		}
	}

	//---процедура вывода на экран массива N
	// ничего не возвращает, просто выводит на консоль
	void Screen_Mass(int* a, unsigned n)
	{
		// массив *a, n – формальные параметры
		// a передаётся как указатель на начало массива, n по значению
		for (unsigned i = 0; i < n; i++)
		{
			cout << "a[" << i << "] = " << a[i] << " ";
		}
		cout << "\n";
	}

	//---функция расчета суммы |a1| + ... + |an|
	// массив *a, n – формальные параметры
	// возвращает сумму типа int
	int Sum_Mass(int* a, unsigned n)
	{
		// определение переменной (объявление + инициализация)
		int sum = 0;
		for (unsigned i = 0; i < n; ++i)
		{
			sum = sum + fabs(a[i]); // fabs - абсолютное значение |a[i]|
		}
		return sum; // возврат суммы sum из функции Sum_Mass
	}

	//---проверка работы функции Sum_Mass на разных входных данных
	// в саму процедуру нет входящих параметров
	void Test_Sum_Mass()
	{
		const double EPS = 10E-8; // допустимая ошибка   
		// динамический массив размерность 3, инициализация всего массива нулями
		int* b = new int [3] {0};

		//проверка через константу EPS, если внутри оператора assert будет ЛОЖЬ,
		//то программа аварийно завершит работу
		b[0] = 0; b[1] = 1; b[2] = 2; // |b0| + |b1| + |b2| = 0 + 1 + 2 = 3
		assert(abs(Sum_Mass(b, 3) - 3) < EPS);

		//обыкновенная проверка, без константы EPS
		b[0] = 2; b[1] = 2; b[2] = 2; // |b0| + |b1| + |b2| = 2 + 2 + 2 = 6
		assert(Sum_Mass(b, 3) == 6); // проверка не через константу EPS

		cout << "test Sum_Mass - OK" << endl;
		//после окончания работы c массивом обязательно освобождаем его память
		delete[] b;
	}

	//-----функция освобождение памяти массива N
	// массив *a формальные параметры
	// ничего не возвращает, просто удаляет память у массива а
	void Del_Mass(int* a)
	{
		delete[] a;
	}
}

// ПРОСТРАНСТВО ИМЕН ДЛЯ МАССИВА В ФАЙЛЕ
namespace NamespaceFile
{
	//---процедурa записи в файл fmass.txt
	// массив *a, n – формальные параметры
	// ничего не возвращает, просто пишет массив в файл
	void WriteFile(int* a, unsigned n)
	{
		// Режим открытия файла для записи ios::out
		// устанавливается при создании файла
		ofstream Fin("fmass.txt", ios::out); //затирает старые и пишет новые данные
		// пишем в файл отправленный массив
		for (unsigned i = 0; i < n; ++i)
		{
			Fin << a[i] << " ";
		}
		Fin << endl;
		Fin.close(); // Функция close() закрывает поток файла
		cout << "Write. End of recording" << endl;
	}

	//---процедурa чтения из файла fmass.txt
	// n – формальные параметры - размерность массива
	// возвращает прочитанный массив b из файла
	int* ReadFile(unsigned n)
	{
		int* b = new int [n] {0};
		ifstream Fout; // объявляем имя Fout для чтения
		//Режим открыть файл для чтения ios::in можно установить при
		//вызове метода open(), необязательно при создании файла(процедура выше)
		Fout.open("fmass.txt", ios::in); //открываем файл для чтения на начале
		//проверяю на наличие файла
		if (!Fout.good())
		{
			cout << "The file fmass.txt was not found !" << endl;
		}
		else
		{
			if (!Fout.eof()) // делаем пока не конец 
				for (int i = 0; i < n; ++i)
				{
					Fout >> b[i];
				}
		}
		Fout.close(); // Функция close() закрывает поток файла
		cout << "Read. End of file" << endl;
		return b;
	}

	//---процедурa добавления записи в файл fmass.txt
	// массив *a, n – формальные параметры
	// ничего не возвращает, просто пишет массив в файл
	void AddFile(int* a, unsigned n)
	{
		//Режим открытия файла для добавления записи ios::app
		//устанавливается при создании файла
		ofstream Fin("fmass.txt", ios::app); // добавление в конец файла
		// пишем в файл отправленный массив
		for (unsigned i = 0; i < n; ++i)
		{
			Fin << a[i] << " ";
		}
		Fin << endl;
		Fin.close(); /// Функция fclose() закрывает поток файла
		cout << "Add. End of recording" << endl;
		cout << "\n";
	}
}