// Бурдинская Наталья – cpp-файл модуля Modul_zd3_massiv1.cpp
// Включение заголовочных файлов стандартной библиотеки.
#include <stdlib.h> // динамического управления памятью, генерации случайных чисел srand и rand
#include <time.h> // объявляет набор функций, макросов и типов для работы с датой и временем
#include <iostream> // Объявляет объекты cin cout, управляющие чтением из стандартных потоков и записью в них.
#include <iomanip> // стандартный для определения нужного числа манипуляторов setw setprecision.
using namespace std; // теперь можно обращаться ко всем именам, описанным в std, непосредственно, без префикса std::

// функция выделение памяти для двумерного массива N х М
// ** объявляет указатель на int, на выходе будет целочисленная матрица А
int** Memo_Mass(unsigned n, unsigned m) 
{
	// n, m – формальныe параметры
	// инициализация всего двумерного массива нулями
	int** a = new int* [n]; // строк N
	for (unsigned i = 0; i < n; i++)
		a[i] = new int[m]{0}; // столбцов M
	return a; // возврат двумерного массива А из функции Memo_Mass
}

// процедура ввода двумерного массива N х М
// Динамические двумерные массивы в функции передаются как указатели **.
// При этом нужно передавать размер через отдельные параметры (n,m).
// на выходе будет та же матрица А, переписанная из нулевой в целочисленную
void Vvod_Mass(int** a, unsigned n, unsigned m)
{
	// а, n, m – формальныe параметры
	// заполнение массива случайными числами от 0 до 100 включительно
    // нумерация (с 0 до n-1) х (с 0 до m-1)
	// Сочетание srand (time (NULL)) устанавливает в качестве базы текущее время.
    // Этот прием часто используется для того, чтобы при разных запусках генератора псевдослучайных чисел
    // была всякий раз разная база и, соответственно, разный ряд получаемых значений.
    // Генерирует случайное число, используя текущею дату, как параметр, как бы для непредсказуемости результата.
    srand(time(0)); // инициализация генератора случайных чисел текущим временем в секундах time

	for (unsigned i = 0; i < n; i++) // строк N
		for (unsigned j = 0; j < m; j++) // столбцов M
	{
        a[i][j] = rand() % 100;
        // rand() возвращает случайное целое число от 0 до RAND_MAX
    }
}

// процедура вывода на экран двумерного массива N х М
// процедура ничего не возвращает
// Динамические двумерные массивы в функции передаются как указатели **.
// При этом нужно передавать размер через отдельные параметры (n,m).
void Screen_Mass(int** a, unsigned n, unsigned m) 
{
	// а, n, m – формальныe параметры
	for (unsigned i = 0; i < n; i++) // строк N
	{
		for (unsigned j = 0; j < m; j++) // столбцов M
			cout << a[i][j]<<" ";
		cout << "\n";
	}
	cout << "\n";
}

// функция создание новой матрицы N х М, с помощью перестановок столбцов
// Динамические двумерные массивы в функции передаются как указатели **.
// При этом нужно передавать размер через отдельные параметры (n,m).
// на входе будет матрица int** a
// на выходе будет другая матрица int** b, созданная перестановкой столбцов
int** Perestanovka_Mass(int** a, unsigned n, unsigned m)
{
	// a, n, m – формальныe параметры
	// инициализация двумерного массива b нулями
	int** b = new int* [n]; // строк N
	for (unsigned i = 0; i < n; i++) // цикл от 0 до n-1
		b[i] = new int[m]{0}; // столбцов M
		
	unsigned k = m / 2; // выделяем целую часть от деления
	unsigned l = m % 2; // выделяем остаток от деления
	for (unsigned i = 0; i < n; i++) // строк N
		for (unsigned j = 0; j < k; j++) // столбцов M
	{
       b[i][j] = a[i][m-j-1]; // перестановка с последних на первые
	   b[i][m-j-1] = a[i][j]; // перестановка с первых на последние
	   if (l==1) b[i][k] = a[i][k]; // если количество столбцов нечетное, тот который в середине остается на месте
    }
	return b;
}

// функция освобождение памяти двумерного массива N х М
void Del_Mass(int** a, unsigned n, unsigned m)
{
for (unsigned i = 0; i < n; i++)
	{
		delete[] a[i];
	}
	delete[] a;
}
